
(ns hoeck.pivot.relations
  (:use clojure.contrib.except
         ;; todo: refactor update functions into their own ns: hoeck.rel.update
        hoeck.pivot.components
        hoeck.pivot.listeners)
  (:require [clojure.set :as set]
            [hoeck.rel.update :as rel-update])
  (:import (org.apache.pivot.collections List ArrayList)
           (org.apache.pivot.collections.concurrent SynchronizedList)
           (org.apache.pivot.util ListenerList)))

(defn pivot-list 
  "Given a relation, return a pivot List of its tuples."
  ;; todo: handle sorted relations so that they return a
  ;;       sorted List and have the comparator already set
  [R]
  (ArrayList. (into-array R)))

(defn relation-model
  "Returns the same relation R wrapped in an atom and connected to a pivot
  List of tuples (available with get-pivot-model).
  `Connected' in the sense that changes to the pivot list will be applied
  (via hoeck.rel.update insert, delete and update) to R.
  To mutate R, use the model-(update, delete, insert) functions."
  [R]
  ;; todo: throw errors if an identical item is inserted
  (let [;; convert R to pivot
        piv (pivot-list R)
        R (ref R :meta {::pivot-model piv})
	ll (list-listener {idx :int l :list :as args}
             :item-inserted (let [ins (.get l idx)
                                  tup (dosync (ref-set R (rel-update/insert @R ins))
                                              (let [i (rel-update/inserts @R)]
                                                (nth i (dec (count i)))))]
                              ;; inserting may add a unique autogenerated pkey field,
                              ;; sync the pivot-list in those cases
                              (when (not= tup ins) (.update l idx tup)))
             :items-removed (dosync (apply alter R #(apply rel-update/delete % (:sequence args))))
             :item-updated (dosync (alter R rel-update/update (:object args) (.get l idx)))
             :list-cleared (dosync (alter R #(apply rel-update/delete % %)))
             :comparator-changed nil)]
    (add-listener piv ll)
    R))

(defn get-pivot-view
  "Return the `thing's existing pivot model"
  [thing]
  (-> thing meta ::pivot-model))

(defn update ;; modify the model, make the view updateable to allow tv-row-editors
  "Update specific keys inside a relation model or a pivot-view thereof.
  For the latter, one may also specify an index of the view instead of a tuple.
  Always returns o."
  ;; todo: throw exceptions
  [o tuple-or-idx & key-val-pairs-or-hashmap]
  (cond (isa? o List) (let [a key-val-pairs-or-hashmap
                            t (if (map? (first a)) (first a) (apply hash-map a))
                            idx (if (integer? tuple-or-idx)
                                  tuple-or-idx
                                  (.indexOf o tuple-or-idx))]
                        (when (= idx -1) (throwf "update tuple not found."))
                        (.update o idx (merge (.get o idx) t)))
        :else (apply update (get-pivot-view o)
                     tuple-or-idx
                     key-val-pairs-or-hashmap))
  o)

(defn insert
  "insert into a relation model, returns the index of the inserted tuples."
  [r & new-tuples]
  (let [m (get-pivot-view r)]
    (doall (map #(.add m %) new-tuples))))

(defn delete
  "delete from a relation model"
  [r & tuples]
  (let [m (get-pivot-view r)]
    (doseq [t tuples]
      (.remove m t))
    r))
